package com.pma.smsecure.Dao;

import com.pma.smsecure.Dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table SMS.
 */
public class SMS {

    private Long id;
    private String message;
    private boolean isRead;
    /** Not-null value. */
    private java.util.Date time;
    /** Not-null value. */
    private String folder;
    private Boolean isEncrypted;
    private Integer phone_id_sms;
    private Long conversationId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient SMSDao myDao;

    private Conversation conversation;
    private Long conversation__resolvedKey;


    public SMS() {
    }

    public SMS(Long id) {
        this.id = id;
    }

    public SMS(Long id, String message, boolean isRead, java.util.Date time, String folder, Boolean isEncrypted, Integer phone_id_sms, Long conversationId) {
        this.id = id;
        this.message = message;
        this.isRead = isRead;
        this.time = time;
        this.folder = folder;
        this.isEncrypted = isEncrypted;
        this.phone_id_sms = phone_id_sms;
        this.conversationId = conversationId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getSMSDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public boolean getIsRead() {
        return isRead;
    }

    public void setIsRead(boolean isRead) {
        this.isRead = isRead;
    }

    /** Not-null value. */
    public java.util.Date getTime() {
        return time;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setTime(java.util.Date time) {
        this.time = time;
    }

    /** Not-null value. */
    public String getFolder() {
        return folder;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setFolder(String folder) {
        this.folder = folder;
    }

    public Boolean getIsEncrypted() {
        return isEncrypted;
    }

    public void setIsEncrypted(Boolean isEncrypted) {
        this.isEncrypted = isEncrypted;
    }

    public Integer getPhone_id_sms() {
        return phone_id_sms;
    }

    public void setPhone_id_sms(Integer phone_id_sms) {
        this.phone_id_sms = phone_id_sms;
    }

    public Long getConversationId() {
        return conversationId;
    }

    public void setConversationId(Long conversationId) {
        this.conversationId = conversationId;
    }

    /** To-one relationship, resolved on first access. */
    public Conversation getConversation() {
        Long __key = this.conversationId;
        if (conversation__resolvedKey == null || !conversation__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ConversationDao targetDao = daoSession.getConversationDao();
            Conversation conversationNew = targetDao.load(__key);
            synchronized (this) {
                conversation = conversationNew;
            	conversation__resolvedKey = __key;
            }
        }
        return conversation;
    }

    public void setConversation(Conversation conversation) {
        synchronized (this) {
            this.conversation = conversation;
            conversationId = conversation == null ? null : conversation.getId();
            conversation__resolvedKey = conversationId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
